<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><!-- jquery--><script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script><!-- bootstrap--><script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.11.0/umd/popper.min.js" integrity="sha384-b/U6ypiBEHpOf/4+1nzFpr53nxSS+GLCkfwBdFNTxtclqqenISfwAzpKaMNFNmj4" crossorigin="anonymous"></script><link rel="stylesheet" href="/vendor/bootstrap/css/bootstrap.min.css" integrity="sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M" crossorigin="anonymous"><script src="/vendor/bootstrap/js/bootstrap.min.js" integrity="sha384-h0AbiXch4ZDo7tp9hKZ4TsHbi047NrKGLO3SEJAg45jXxnGIfYzk4Si90RDIqNm1" crossorigin="anonymous"></script><!-- font awesome--><link rel="stylesheet" href="/vendor/font-awesome/css/font-awesome.min.css"><!-- syntax hilighting--><link rel="stylesheet" href="/vendor/highlightjs/css/atom-one-dark.css"><!-- styles--><link rel="stylesheet" href="/src/styles.css"><!--scripts--><script src="/src/bundle.js"></script><title>Pixel Data | Comp Form</title></head><body class="comp-form"><div id="logo"><svg width="20px" height="18px" viewbox="0 0 20 18" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs></defs><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Desktop" transform="translate(-18.000000, -16.000000)" fill="#000000"><g id="Compform-Logo" transform="translate(18.000000, 16.000000)"><polygon id="Triangle-Copy-4" points="15 9 20 18 10 18"></polygon><polygon id="Triangle-Copy-5" points="5 9 10 18 0 18"></polygon><polygon id="Triangle-Copy-6" points="10 0 15 9 5 9"></polygon></g></g></g></svg></div><header class="container" id="top-nav"><div class="row justify-content-md-center"><div class="col-md-8"><span class="title">Pixel Data</span><div class="buttons"><a class="previous" href="../strategy"><i class="fa fa-caret-left fa-lg"></i>Strategy</a><a class="next" href="../strategy">Strategy<i class="fa fa-caret-right fa-lg"></i></a></div></div></div></header><div id="content"><div class="container" id="hero"><div class="row justify-content-md-center"><div class="col-md-8"><h1>Pixel Data</h1><h6>The What</h6><p class="description">Access pixel values directly to process and generate images.</p><h6>The How</h6><p class="software">p5.js</p></div></div></div><div class="container" id="copy"><div class="row justify-content-md-center"><div class="col-md-8 comp-form-copy"><h2 id="learning-objectives">Learning Objectives</h2>
<ul>
<li>Understand how raster image data is represented in memory.</li>
<li>Explore image generation and image processing.</li>
<li>Explore using an image as a data input.</li>
<li>Technical: Using p5’s <code>get()</code> and <code>set()</code> function to read and write pixel values.</li>
<li>Technical: Using p5’s <code>pixel[]</code> array to work with pixel data directly.</li>
</ul>
<h2 id="raster-images">Raster Images</h2>
<h3 id="the-pixel-array">The pixel array</h3>
<p>[diagram]
[get and set are slow, really slow, and why]</p>
<h3 id="rasterization">Rasterization</h3>
<p>[p5 rasterizes high-level descriptions to pixel values as you go (immediate mode?)]
[vector images are rasterized before they are shown]</p>
<h3 id="raster-vs-vector-images">Raster vs Vector Images</h3>
<p>[How raster images are stored in memory]</p>
<p>[Not just about scalability. Scalability is the most often mentioned difference between raster and vector images, but other differences exist as well. Because vector images are described at a higher level—shapes instead of pixels—they are also easier to distort, recolor, change the stroke, etc. Not all images can be reasonably described as a collection of shapes. Photographic images, in particular, have too much detail to store as a collection of shapes. Similarly, some types of effects that consume or produce pixel-level detail require raster data, more information about what the images is made of, rather than what it looks like now]</p>
<p>[slide show]</p>
<h2 id="writing-pixel-data">Writing Pixel Data</h2>
<p>[intro?]</p>
<h3 id="a-basic-example">A Basic Example</h3>
<p>The p5.js library provides two ways to read and write image pixel data. First,you can use <code>get()</code> and <code>set()</code> which are a bit easier but slower. Second you can access the <code>pixels[]</code> array directly, which is faster but requires some math to find the address of the pixel you want to work with.</p>
<p>This example uses <code>set()</code> to create some random pixel data.</p>
<div id="" class="">
<div class="js-lab">
<iframe class="js-lab" src="/js_lab/js_lab.html?/comp_form/pixels/sketches/basic_pixels.js">
</iframe>
</div>
</div>
<p>Let’s look at the code in depth.</p>
<dl>
<dt>Line 10</dt>
<dd>Use <code>createImage()</code> to create a new, empty image in memory. We can draw this image just like an image lowed from a <code>.jpg</code> or <code>.gif</code>.</dd>
<dt>Line 11</dt>
<dd>Use <code>loadPixels()</code> to tell p5 that we want to access the pixels of the image for reading or writing. You must call <code>loadPixels()</code> before using <code>set()</code>, <code>get()</code>, or the <code>pixels[]</code> array.</dd>
<dt>Line 13</dt>
<dd>Set up a nested loop. The inner content of the loop will be run once for every pixel.</dd>
<dt>Line 15</dt>
<dd>Use the <code>color()</code> function to create a color value, which is assigned to <code>c</code>. Color values hold the R, G, B, and A values of a color. The color function takes into account the current <code>colorMode()</code>.</dd>
<dt>Line 16</dt>
<dd>Use <code>set()</code> to set the color of the pixel at <code>x, y</code>.</dd>
<dt>Line 20</dt>
<dd>Use <code>updatePixels()</code> to tell p5 we are done accessing the pixels of the image.</dd>
<dt>Line 22</dt>
<dd>Use <code>noSmooth()</code> to tell p5 not to smooth the image when we scale it; we want it pixelated. This Photoshop’s ‘nearest neighbor’ scaling method.</dd>
<dt>Line 23</dt>
<dd>Draw the image, filling the canvas so we can clearly see each pixel.</dd>
</dl>
<h3 id="gradient-example">Gradient Example</h3>
<p>This example has the same structure as the first one, but draws a gradient pixel-by-pixel.</p>
<div id="" class="">
<div class="js-lab">
<iframe class="js-lab" src="/js_lab/js_lab.html?/comp_form/pixels/sketches/basic_pixels_2.js">
</iframe>
</div>
</div>
<dl>
<dt>Line 15</dt>
<dd>Instead of choosing a color at random, this example calculates a color based on the current <code>x</code> and <code>y</code> position of the pixel being set.</dd>
</dl>
<h3 id="random-access-example">Random Access Example</h3>
<p>The first two examples use a nested loop to set a value for every pixel in the image; it visits every pixel in a sequential order. That pattern is commonly used in pixel generating and processing scripts, but not always. This example places red pixels at random places on the image.</p>
<div id="" class="">
<div class="js-lab">
<iframe class="js-lab" src="/js_lab/js_lab.html?/comp_form/pixels/sketches/basic_pixels_3.js">
</iframe>
</div>
</div>
<div id="" class="activity">
<h2 id="in-class-challenge-one">In-class Challenge One</h2>
<p>Explore using p5’s pixel manipulation functions by modifying the scripts above. Work through the following challenges in order. <br/> Don’t skip any.</p>
<table class="table table-responsive">
<thead>
<tr>
<th>Time</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; 13 in 20 Minutes</td>
<td>You need to put in some extra work<br/> to strengthen your programming understanding.</td>
</tr>
<tr>
<td>13 in 20 Minutes</td>
<td>Good.</td>
</tr>
<tr>
<td>All in 20 Minutes</td>
<td>Great.</td>
</tr>
<tr>
<td>All in 15 Minutes</td>
<td>Hot Dang!</td>
</tr>
</tbody>
</table>
<h3 id="modify-the-basic-example">Modify the Basic Example</h3>
<ol>
<li>Change the image resolution to <code>20x20</code></li>
<li>Change the image resolution to <code>500x500</code></li>
<li>Change the image resolution back to <code>10x10</code></li>
<li>Make each pixel a random shade of blue.</li>
<li>Make each pixel a random shade of gray.</li>
</ol>
<h3 id="modify-the-gradient-example">Modify the Gradient Example</h3>
<ol start="6" class="continue">
<li>Make a horizontal black to blue gradient.</li>
<li>Make a vertical green to black gradient.</li>
<li>Make a horizontal white to blue gradient.</li>
<li>Make a vertical rainbow gradient. Tip: <code>colorMode()</code></li>
<li>Create an inset square with a gradient, surrounded by randomly colored pixels.</li>
</ol>
<h3 id="modify-the-random-access-example">Modify the Random Access Example</h3>
<ol start="11" class="continue">
<li>Change the image resolution to <code>50x50</code>, adjust scatter to fill.</li>
<li>Instead of drawing single pixels, draw little <code>+</code> marks at random locations.</li>
<li>Make each <code>+</code> a random color.</li>
</ol>
<h3 id="challenging-challenges">Challenging Challenges</h3>
<ol start="14" class="continue">
<li>Color each pixel with <code>noise()</code> to visualize its values.</li>
<li>Make a radial gradient from black to red. Tip: <code>dist()</code></li>
<li>Create a diagonal gradient.</li>
<li>Use <code>sin()</code> to create a repeating black to red to black color wave.</li>
<li>Create a <code>128x128</code> image and set the blue value of each pixel to <code>(y&amp;x) * 16</code></li>
</ol>
</div>
<h2 id="reading-pixel-data">Reading Pixel Data</h2>
<p>The p5.js library also allows you to read pixel data, so you can process images or use images a inputs. These examples use this low-res black-and-white image of Earth.</p>
<img class="scale pixel" style="image-rendering: pixelated; height: 120px;" src="sketches/world.png" />
<h3 id="read-pixels-example-1">Read Pixels Example 1</h3>
<p>This example loads the image of Earth, loops over its pixels, and multiplies each pixels color with a random color.</p>
<div id="" class="">
<div class="js-lab">
<iframe class="js-lab" src="/js_lab/js_lab.html?/comp_form/pixels/sketches/read_pixels.js">
</iframe>
</div>
</div>
<h4 id="first-we-need-to-load-an-image-to-read-pixel-data-from">First we need to load an image to read pixel data from.</h4>
<dl>
<dt>Line 3</dt>
<dd>Declare a variable to hold our image.</dd>
<dt>Line 5</dt>
<dd>The <code>preload()</code> function. Use this function to load assets. p5.js will wait until all assets are loaded before calling <code>setup()</code> and <code>draw()</code></dd>
<dt>Line 6</dt>
<dd>Load the image.</dd>
</dl>
<h4 id="with-our-image-loaded-we-can-process-the-pixels">With our image loaded we can process the pixels.</h4>
<dl>
<dt>Line 18</dt>
<dd>Set up a nested loop to cover every pixel.</dd>
<dt>Line 20</dt>
<dd>Use <code>get()</code> to load the color data of the current pixel. <code>get()</code> returns an array like <code>[255, 0, 0, 255]</code> with components for red, green, blue, and alpha.</dd>
<dt>Lines 22, 23, 24</dt>
<dd>Read the red, blue, and green parts of the color.</dd>
<dt>Line 25</dt>
<dd>Create the new color for the pixel by multiplying the current color values with a random 0-1 value.</dd>
<dt>Line 27</dt>
<dd>Change the pixel to our new color.</dd>
<dt>Line 28</dt>
<dd>Uses <code>updatePixels()</code> to tell the image there has been an update. We didn’t need to do this in every pass through the loop when we were just setting pixels, but here we mix <code>set()</code> and <code>get()</code>. p5.js requires calling <code>updatePixels()</code> anytime we switch from setting to getting or drawing.</dd>
</dl>
<h3 id="read-pixels-example-2">Read Pixels Example 2</h3>
<p>This example compares each pixel to the one below it. If the upper pixel is darker, it is changed to magenta.</p>
<div id="" class="">
<div class="js-lab">
<iframe class="js-lab" src="/js_lab/js_lab.html?/comp_form/pixels/sketches/read_pixels_2.js">
</iframe>
</div>
</div>
<h3 id="image-as-input-example">Image as Input Example</h3>
<p>This example doesn’t draw the image at all. Instead, the image is used as an input that controls where the red ellipses are drawn. Using images an inputs is a powerful technique that allows you to mix manual art and procedurally generated content.</p>
<div id="" class="">
<div class="js-lab">
<iframe class="js-lab" src="/js_lab/js_lab.html?/comp_form/pixels/sketches/read_pixels_3.js">
</iframe>
</div>
</div>
<div id="" class="activity">
<h2 id="in-class-challenge-two">In-class Challenge Two</h2>
<p>Explore using p5’s pixel manipulation functions by modifying the scripts above. Work through the following challenges in order. <br/> Don’t skip any.</p>
<table class="table table-responsive">
<thead>
<tr>
<th>Time</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; 10 in 20 Minutes</td>
<td>You need to put in some extra work<br/> to strengthen your programming understanding.</td>
</tr>
<tr>
<td>10 in 20 Minutes</td>
<td>Good.</td>
</tr>
<tr>
<td>All in 20 Minutes</td>
<td>Great.</td>
</tr>
<tr>
<td>All in 15 Minutes</td>
<td>Hot Dang!</td>
</tr>
</tbody>
</table>
<h3 id="modify-example-1">Modify Example 1</h3>
<ol>
<li>Colorize the white pixels with a vertical black to red gradient.</li>
<li>Colorize the black pixels with a vertical black to green gradient.</li>
<li>Feed the program you made above a grayscale or color image (under 100x100). <br/> You’ll have to do this in your own editor, and you’ll need a local server.</li>
</ol>
<img src="sketches/world_100.png" style="image-rendering: pixelated;">
<h3 id="modify-example-2">Modify Example 2</h3>
<ol start="4" class="continue">
<li>Change the color comparison to <code>&gt;</code>.</li>
<li>Change the color comparison to <code>!=</code>.</li>
<li>Change <code>out_color</code> to an average of the two color samples.</li>
<li>Feed the program you made above the grayscale earth image above.</li>
</ol>
<h3 id="modify-example-3">Modify Example 3</h3>
<ol start="8" class="continue">
<li>Invert the drawing, so that circles appear where the input pixels are black.</li>
<li>Feed the program you made above the grayscale earth image above.</li>
<li>Use lightness to drive the circle sizes.</li>
</ol>
<h3 id="challenging-challenges-2">Challenging Challenges</h3>
<ol start="11" class="continue">
<li>Start with the original Example 2 code, without your changes. Set <code>out_color</code> to the average of <code>this_color</code> and <code>below_color</code>.</li>
<li>Change <code>worldImage.set(x, y, out_color);</code> to <code>worldImage.set(x, y+1, out_color);</code>.</li>
<li>Remove the conditional statement (keep its contents).</li>
</ol>
</div>
<h2 id="advanced-topics">Advanced Topics</h2>
<h3 id="the-canvas-pixel-density">The Canvas + Pixel Density</h3>
<p>When accessing the pixel data of the canvas itself, you need to consider the pixel density p5 is using. By default p5 will create a 2x resolution canvas when running on a high-dpi (retina) display. You can call <code>pixelDensity(1)</code> to disable this feature. If you don’t, you’ll need to take into account the density when calculating a position in the <code>pixels[]</code> array.</p>
<p>The examples on this page work with the pixels of images instead of the canvas to avoid this issue altogether.</p>
<h3 id="performance">Performance</h3>
<p>The built-in p5 <code>someImage.get(x, y)</code> function gets the RGBA values of a pixel in an image. As noted in the <a href="https://p5js.org/reference/#/p5/get">reference</a>, the get call is slower than accessing the values in the <code>someImage.pixels[]</code> array directly. In fact, <code>get()</code> can be 1000s of times slower. Under the hood, <code>get()</code> reads the colors of every pixel in the image before returning the value you request.</p>
<p>We can get much faster results by loading the pixel values <strong>once</strong> with <code>loadPixels()</code>, and then reading from the <code>pixels[]</code> array directly.</p>
<p>The <code>getQuick()</code> funciton below reads a pixels color value from an image’s <code>pixels[]</code> array. You must call <code>loadPixels()</code> before calling this funciton.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// find the RGBA values of the pixel at x, y in the img's pixels array</span>
<span class="hljs-comment">// use instead of p5s built in .get(x,y), for much better performance (more than 1000x better in many cases)</span>
<span class="hljs-comment">// see: http://p5js.org/reference/#/p5/pixels[]</span>
<span class="hljs-comment">// we don't need to worry about screen pixel density here, because we are not reading from the screen</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getQuick</span>(<span class="hljs-params">img, x, y</span>) </span>{

	<span class="hljs-keyword">var</span> i = (y * img.width + x) * <span class="hljs-number">4</span>;
	<span class="hljs-keyword">return</span> [
		testImage.pixels[i],
		testImage.pixels[i+<span class="hljs-number">1</span>],
		testImage.pixels[i+<span class="hljs-number">2</span>],
		testImage.pixels[i+<span class="hljs-number">3</span>],
	];
}
</code></pre>
<p>Copy the <code>getQuick()</code> function above into your sketch. You can then replace a built in p5 <code>get</code> call with a call to <code>getQuick</code>:</p>
<h4 id="using-get">Using <code>get()</code></h4>
<pre><code class="language-javascript"><span class="hljs-comment">// in loop</span>
c = img.get(x, y);
</code></pre>
<h4 id="using-getquick">Using <code>getQuick()</code></h4>
<pre><code class="language-javascript"><span class="hljs-comment">// before loop</span>
img.loadPixels();

<span class="hljs-comment">// in loop</span>
c = getQuick(img, x, y);
</code></pre>
<p>The following example compares the performance of using <code>get()</code> and <code>getQuick()</code> to read and invert the color value of a small image.</p>
<div id="" class="">
<div class="js-lab">
<iframe class="js-lab" src="/js_lab/js_lab.html?/comp_form/pixels/sketches/performance.js">
</iframe>
</div>
</div>
<h2 id="study-example">Study Example</h2>
<p>This example uses an image as an input to control the density and placement of drawn grass.</p>
<h4 id="input-image">Input Image</h4>
<p class="scale"><img src="./sketches/cf.png" alt="cf.png"></p>
<div id="" class="">
<div class="js-lab">
<iframe class="js-lab" src="/js_lab/js_lab.html?/comp_form/pixels/sketches/grass.js">
</iframe>
</div>
</div>
<div id="" class="assignment">
<h2 id="keep-sketching">Keep Sketching!</h2>
<h3 id="base">Base</h3>
<p class="bigger">Explore working with image pixel data directly. This week, most of your posts should be still images. You might also consider creating animations. Since p5 pixel access is slow, this technique will pair well with pre-rendering.</p>
<p>Post <strong>at least one</strong> sketch <strong>for each</strong> of the following:</p>
<ol>
<li>Generate an image from scratch: pixel by pixel. Don’t call any high level drawing function like <code>ellipse()</code> or <code>rect()</code>.</li>
<li>Load an image and process its pixels. Show the result.</li>
<li>Use an image as an input source to control a drawing. Don’t show the original image, just the output.</li>
</ol>
<h3 id="challenge">Challenge</h3>
<p>Create a pixel Ouroboros.
Create code that processes an image. Feed the result back into your code and process it again. What happens after several generations?</p>
<p>Post your source image, the result after one generation, and the result after several generations. Alternately, capture 90 generations as frames and post as a video.</p>
</div>
<h2 id="misc-links">Misc Links</h2>
<div id="" class="links">
<p><a href="https://vimeo.com/61154654">Reaction Diffusion in Photoshop</a>
<a href="http://store.steampowered.com/app/427520/">Factorio</a>
<a href="http://brianmacintosh.com/iconmachine/">Icon Machine</a></p>
</div></div></div></div><div class="container" id="scroll-out"></div></div></body></html>